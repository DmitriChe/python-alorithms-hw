# 1. Подсчитать, сколько в программе было выделено памяти под переменные.
# Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
# Результаты анализа вставьте в виде комментариев к коду.
# P.S. Напишите в комментариях версию Python и разрядность ОС.

import random
import sys


def get_size(x, level=0):  # level  для сдвига табуляции для красивого вывода

    # Выведем тип объекта, его размер в памяти и сам объект:
    print('\t' * level, f'type = {x.__class__}, size = {sys.getsizeof(x)}, object = {x}')

    # для составных объектов
    if hasattr(x, '__iter__'):  # т.е. если наш объект итерируемый, а зачит составной (список, словать, кортеж и т.д.)

        if hasattr(x, '__items__'):  # т.е. если этот объект СЛОВАРЬ - т.к. только у него есть аттрибут items
            for xx, in x.items():
                get_size(xx, level + 1)

        elif not isinstance(x, str):  # если наш объект не словарь и не строка (то это кортеж, словарь или множенство)
            for xx in x:
                get_size(xx, level + 1)

    return sys.getsizeof(x)


def total_size(lst):

    total_mem = 0

    for itm in lst:
        total_mem += get_size(itm)

    return total_mem


# Задача 4. Определить, какое число в массиве встречается чаще всего.

arr = sorted([random.randint(0, 100) for _ in range(100)])
print(arr)

max_count = 0
count = 1
most_frequent_nums = []

for i in range(len(arr) - 1):

    if arr[i] == arr[i + 1]:
        count += 1

    else:
        if count == max_count:
            most_frequent_nums.append(arr[i])
        if count > max_count:
            max_count = count;
            most_frequent_nums = [arr[i]]

        count = 1

print(f'Список чисел с максимальной частотностью ({max_count}) : {most_frequent_nums}')


# Подсчет использования памяти
print('*' * 72)
var_list = [arr, max_count, count, most_frequent_nums, i]

print(f'\nОбщий объем занятой под переменные памяти:\n{total_size(var_list)} байт\n')

# Версия Python 3.7.0 и разрядность OS
print(f'Версия Python 3.7.0 и разрядность OS\n{sys.version}')

# Выводы:
# Под целое число отводится 14 байт (в 64 разрядной ОС). Эта память выделяется сразу (статически),
# так как размер объекта известен заранее.
# При хранении списков:
# - с одной стороны, память выделяется динамически, так как граничный размер объекта заранее неизвестен.
# поэтому, за счет резервной аллокации размер массива чуть больше, чем в нем значений.
# - с другой стороны, за счет ссылочной системы, элементы массива с одним значением ссылаются
# на ячейку с этим значением и т.о. происходит экономия памяти. По-видимому именно этим объясняется тот факт, что
# мой массив из 100 элементов по 14 байт в сумме занимает лишь 508, а не 1400 байт.
# Оптимизировать программу по скорости выполения можно за счет предварительного выделения памяти под массив,
# так как его размер заранее известен - т.е. объявить массив заранее. Т.о. можно было бы сократить время
# на динамическое выделение памяти в процессе генерации списка.

