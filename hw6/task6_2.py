# 1. Подсчитать, сколько в программе было выделено памяти под переменные.
# Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
# Результаты анализа вставьте в виде комментариев к коду.
# P.S. Напишите в комментариях версию Python и разрядность ОС.

import random
import sys


def get_size(x, level=0):  # level  для сдвига табуляции для красивого вывода

    # Выведем тип объекта, его размер в памяти и сам объект:
    print('\t' * level, f'type = {x.__class__}, size = {sys.getsizeof(x)}, object = {x}')

    # для составных объектов
    if hasattr(x, '__iter__'):  # т.е. если наш объект итерируемый, а зачит составной (список, словать, кортеж и т.д.)

        if hasattr(x, '__items__'):  # т.е. если этот объект СЛОВАРЬ - т.к. только у него есть аттрибут items
            for xx, in x.items():
                get_size(xx, level + 1)

        elif not isinstance(x, str):  # если наш объект не словарь и не строка (то это кортеж, словарь или множенство)
            for xx in x:
                get_size(xx, level + 1)

    return sys.getsizeof(x)


def total_size(lst):

    total_mem = 0

    for itm in lst:
        total_mem += get_size(itm)

    return total_mem


# 3. В массиве случайных целых чисел поменять местами минимальный и максимальный элементы.
print('\n' + '*' * 27 + ' Задача (вариант 1) ' + '*' * 27 + '\n')
arr = [random.randint(0, 100) for _ in range(10)]
print(f'{arr} - исходный массив')
min_num = max_num = arr[0]
min_idx = max_idx = 0

for i in range(len(arr)):
    if arr[i] < min_num:
        min_num = arr[i]
        min_idx = i
    if arr[i] > max_num:
        max_num = arr[i]
        max_idx = i

spam = arr[min_idx]
arr[min_idx] = arr[max_idx]
arr[max_idx] = spam

print(f'{arr} - перестановка (варинт 1)')

# Подсчет использования памяти
print('\n' + '*' * 27 + ' Подсчет памяти (вариант 1) ' + '*' * 27 + '\n')
var_list = [arr, min_num, min_idx, max_num, max_idx, spam, i]
print(f'\nОбщий объем занятой под переменные памяти:\n{total_size(var_list)} байт\n')

# Вариант 2
print('\n' + '*' * 27 + ' Задача (вариант 2) ' + '*' * 27 + '\n')
arr[arr.index(max(arr))], arr[arr.index(min(arr))] = arr[arr.index(min(arr))], arr[arr.index(max(arr))]
print(f'{arr} - перестановка (варинт 2)')

# Подсчет использования памяти
print('\n' + '*' * 27 + ' Подсчет памяти (вариант 2) ' + '*' * 27 + '\n')
var_list = [arr, max(arr), min(arr)]
print(f'\nОбщий объем занятой под переменные памяти:\n{total_size(var_list)} байт\n')


# Версия Python 3.7.0 и разрядность OS
print(f'Версия Python 3.7.0 и разрядность OS\n{sys.version}')

# Выводы:
# Под целое число отводится 14 байт (в 64 разрядной ОС). Эта память выделяется сразу (статически),
# так как размер объекта известен заранее.
# При хранении списков:
# - с одной стороны, память выделяется динамически, так как граничный размер объекта заранее неизвестен.
# поэтому, за счет резервной аллокации размер массива чуть больше, чем в нем значений.
# - с другой стороны, за счет ссылочной системы, элементы массива с одним значением ссылаются
# на ячейку с этим значением и т.о. происходит экономия памяти. По-видимому именно этим объясняется тот факт, что
# мой массив из 10 элементов по 14 байт в сумме занимает лишь 100, а не 140 байт.
# ХОТЯ, ЭТОГО ОБЪЯСНЕНИЯ ЯВНО НЕ ДОСТАТОЧНО. ЧТО-ТО ЗДЕСЬ ЕЩЕ КРОЕТСЯ..

# Т.к. все числа в задаче целые и не превышают 255, то время на их генерацию не тратится,
# ибо они уже любезно созданы Гвидо ван Россумом (Российским умом?? Гвидон? О Боже! диво!)

# За счет меньшего числа промежуточных переменных, второй вариант решения задачи менее затратен по памяти:
# 128 против 184 байт

